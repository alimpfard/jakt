namespace Reflect {
    struct StructId {
        id: usize
        module_id: usize
    }
    struct EnumId {
        id: usize
        module_id: usize
    }
    struct TypeId {
        id: usize
        module_id: usize
    }

    struct Span {
        start: usize
        end: usize
        file: String
    }
    enum Visibility {
        Public
        Private
        // Restricted(whitelist: [Reflect::Type])
    }
    struct VariableDeclaration {
        name: String
        type: Reflect::Type
        is_mutable: bool
    }
    struct Field {
        variable: Reflect::VariableDeclaration
        visibility: Reflect::Visibility
        // comptime setter<T, U>(this) throws {
        //     let name = .variable.name
        //     return fn[name](anon s: &mut T, anon value: U) throws {
        //         Reflect::Internal::set_field(name, s, value)
        //     }
        // }
    }
    struct Method {
        function: Reflect::Function
        visibility: Reflect::Visibility
    }
    struct Function {
        name: String
        // parameters: [Reflect::Parameter]
        generic_parameters: [String]
        // block: Reflect::Block
        return_type: Reflect::Type
        can_throw: bool
        is_comptime: bool
    }
    enum SumEnumVariant {
        StructLike(name: String, fields: [Reflect::Field])
        Typed(name: String, type: Reflect::Type)
        Untyped(name: String)
    }
    enum RecordType {
        Struct(
            existing_id: Optional<Reflect::StructId> = None
            fields: [Reflect::Field]
        )
        Class(
            existing_id: Optional<Reflect::StructId> = None
            fields: [Reflect::Field]
        )
        // ValueEnum(existing_id: Reflect::EnumId?, underlying_type: Reflect::Type, variants: [Reflect::ValueEnumVariant])
        SumEnum(
            existing_id: Optional<Reflect::EnumId> = None
            is_boxed: bool
            variants: [Reflect::SumEnumVariant]
        )
    }
    struct Record {
        name: String
        methods: [Reflect::Method]
        generic_mappings: [(String, Reflect::Type)]
        record_type: Reflect::RecordType
    }
    boxed enum Type {
        existing_id: Optional<Reflect::TypeId> = None

        Void
        Bool
        U8
        U16
        U32
        U64
        I8
        I16
        I32
        I64
        F32
        F64
        Usize
        JaktString
        CChar
        CInt
        Unknown
        Never
        StructureOrEnum(record: Reflect::Record)
        TypeVariable(name: String)
        RawPtr(type: Reflect::Type)
        Reference(type: Reflect::Type)
        MutableReference(type: Reflect::Type)
        Function

        fn name(this) throws => match this {
            Void => "void"
            Bool => "bool"
            U8 => "u8"
            U16 => "u16"
            U32 => "u32"
            U64 => "u64"
            I8 => "i8"
            I16 => "i16"
            I32 => "i32"
            I64 => "i64"
            F32 => "f32"
            F64 => "f64"
            Usize => "usize"
            JaktString => "String"
            CChar => "c_char"
            CInt => "c_int"
            Unknown => "unknown"
            Never => "never"
            StructureOrEnum(record) => format("struct {}", record.name)
            TypeVariable(name) => format("{}", name)
            RawPtr(type) => format("raw {}", type.name())
            Reference(type) => format("& {}", type.name())
            MutableReference(type) => format("&mut {}", type.name())
            Function => "fn"
        }
    }
}
